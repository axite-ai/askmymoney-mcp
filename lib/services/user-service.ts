/**
 * User Service
 *
 * Manages user-to-Plaid item mappings in the database.
 * Links Better Auth users to their connected bank accounts (Plaid items).
 * All Plaid access tokens are encrypted at rest using AES-256-GCM.
 */

import { eq, and, desc } from 'drizzle-orm';
import { db } from '../db';
import { plaidItems } from '../db/schema';
import { EncryptionService } from './encryption-service';

export interface PlaidItem {
  id: string;
  userId: string;
  itemId: string;
  accessToken: string; // Decrypted token
  institutionId: string | null;
  institutionName: string | null;
  status: string | null;
  consentExpiresAt: Date | null;
  createdAt: Date;
  updatedAt: Date;
}

/**
 * Service for managing user Plaid items
 */
export class UserService {
  /**
   * Save a Plaid item for a user
   *
   * @param userId - Better Auth user ID
   * @param itemId - Plaid item ID
   * @param accessToken - Plaid access token (will be encrypted before storage)
   * @param institutionId - Optional institution ID
   * @param institutionName - Optional institution name
   */
  public static async savePlaidItem(
    userId: string,
    itemId: string,
    accessToken: string,
    institutionId?: string,
    institutionName?: string
  ): Promise<PlaidItem> {
    // Encrypt the access token before storing
    const encryptedToken = EncryptionService.encrypt(accessToken);

    const [item] = await db
      .insert(plaidItems)
      .values({
        // id will be auto-generated by schema default
        userId,
        itemId,
        accessToken: encryptedToken,
        institutionId: institutionId || null,
        institutionName: institutionName || null,
        status: 'active',
      })
      .onConflictDoUpdate({
        target: plaidItems.itemId, // itemId is unique
        set: {
          userId, // Update userId in case it changed
          accessToken: encryptedToken,
          institutionId: institutionId || null,
          institutionName: institutionName || null,
          status: 'active',
        },
      })
      .returning();

    // Return item with decrypted token
    return {
      ...item,
      accessToken: EncryptionService.decrypt(item.accessToken),
    };
  }

  /**
   * Get all Plaid items for a user
   *
   * @param userId - Better Auth user ID
   * @param activeOnly - Only return active items (default: true)
   */
  public static async getUserPlaidItems(
    userId: string,
    activeOnly: boolean = true
  ): Promise<PlaidItem[]> {
    const items = await db
      .select()
      .from(plaidItems)
      .where(
        activeOnly
          ? and(eq(plaidItems.userId, userId), eq(plaidItems.status, 'active'))
          : eq(plaidItems.userId, userId)
      )
      .orderBy(desc(plaidItems.createdAt));

    // Decrypt access tokens
    return items.map(item => ({
      ...item,
      accessToken: EncryptionService.decrypt(item.accessToken),
    }));
  }

  /**
   * Get a specific Plaid item by item ID
   *
   * @param userId - Better Auth user ID (for security)
   * @param itemId - Plaid item ID
   */
  public static async getPlaidItem(
    userId: string,
    itemId: string
  ): Promise<PlaidItem | null> {
    const [item] = await db
      .select()
      .from(plaidItems)
      .where(and(eq(plaidItems.userId, userId), eq(plaidItems.itemId, itemId)))
      .limit(1);

    if (!item) return null;

    // Return item with decrypted token
    return {
      ...item,
      accessToken: EncryptionService.decrypt(item.accessToken),
    };
  }

  /**
   * Get all access tokens for a user's active items
   *
   * Useful for aggregating data across all connected accounts
   */
  public static async getUserAccessTokens(userId: string): Promise<string[]> {
    const items = await this.getUserPlaidItems(userId, true);
    return items.map(item => item.accessToken);
  }

  /**
   * Mark a Plaid item as having an error
   *
   * @param userId - Better Auth user ID
   * @param itemId - Plaid item ID
   * @param errorCode - Plaid error code
   */
  public static async markItemError(
    userId: string,
    itemId: string,
    errorCode: string
  ): Promise<void> {
    console.log(`[UserService] Marking item ${itemId} as error with code: ${errorCode}`);
    await db
      .update(plaidItems)
      .set({
        status: 'error',
        // errorCode field doesn't exist in schema - just log it
      })
      .where(and(eq(plaidItems.userId, userId), eq(plaidItems.itemId, itemId)));
  }

  /**
   * Mark a Plaid item as revoked (user disconnected)
   *
   * @param userId - Better Auth user ID
   * @param itemId - Plaid item ID
   */
  public static async revokeItem(userId: string, itemId: string): Promise<void> {
    await db
      .update(plaidItems)
      .set({
        status: 'revoked',
      })
      .where(and(eq(plaidItems.userId, userId), eq(plaidItems.itemId, itemId)));
  }

  /**
   * Delete a Plaid item completely
   *
   * Use sparingly - prefer revokeItem() for soft deletion
   */
  public static async deletePlaidItem(
    userId: string,
    itemId: string
  ): Promise<void> {
    await db
      .delete(plaidItems)
      .where(and(eq(plaidItems.userId, userId), eq(plaidItems.itemId, itemId)));
  }
}
